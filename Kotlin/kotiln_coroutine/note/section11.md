# 루틴, 서브루틴, 코루틴
- 루틴이란? 특정한 일을 하기 위한 일련의 처리과정.
- 프로그래밍에서는 루틴을 "특정한 일을 하기 위한 일련의 명령"이라는 의믜리 사용하고, **이를 함수 또는 메소드라고도 부른다.**
- 서브루틴이란? **함수내에서 함수가 호출될 경우 호출된 함수**를 서브 루틴이라 한다. 
## 서브루틴
- 서브루틴은 한번 실행되면 끝까지 실행된다.
- 루틴에 의해 서브루틴이 호출되면 루틴을 실행하던 스레드는 서브루틴을 실행하는데 사용돼 서브루틴의 실행이 완료될 때까지 다른 작업을 할 수 없다.
## 코루틴
- 코루틴은 함께 실행되는 루틴으로 **서로 간에 스레드 사용을 양보**하며 함께 실행된다.

# 코루틴의 스레드 양보
- 코루틴은 작업 중간에 스레드의 사용이 필요 없어지면 스레드를 양보한다.
- **스레드를 양보하는 주체는 코루틴이다.** 따라서 스레드를 양보하기 위해서는 코루틴이 직접 스레드 양보를 위한 함수를 호출해야한다.
- 작업을 일정 시간동안 일시중단해야 할 경우 delay 함수를 사용할 수 있다. (Code11-1.kt 참조)
## join과 await의 양보
- Job의 join함수나 Deferred의 await 함수가 호출되면 해당 함수를 호출한 코루틴은 스레드를 양보하고, join 또는 await의 대상이 된 코루틴이 완료될 때까지 일시중단된다.
- 하나의 코루틴이 스레드를 양보하지 않으면 다른 코루틴은 스레드를 점유하지 못한다.

## yield 함수를 통한 양보
- 특정 상황에서는 `yield`함수를 통해 직접 스레드를 양보하는것이 필요하다.
- 특히, 단일 스레드만 사용하는 상황에서는 명시적으로 사용해야하는 경우가 종종 생긴다.
### 양보가 안되는 상황
```kotlin
fun main() = runBlocking<Unit> {
  val job = launch {
    while (this.isActive) {
      println("작업 중")
    }
  }
  delay(100L) // 100밀리초간 일시 중단
  job.cancel() // job이 계속 메인스레드를 점유하고 있어서, job이 취소되지 않는다.
}
```
### 양보가 되는 상황
```kotlin
fun main() = runBlocking<Unit> {
    val whileJob = launch(Dispatchers.Default) { // 코루틴을 백그라운드 스레드에서 실행
        while (this.isActive) {
            println("작업중")
        }
    }
    
    delay(100)
    whileJob.cancel() //취소됨.
}
```

# 코루틴의 실행 스레드
### 코루틴의 실행 스레드는 고정이 아님.
- 코루틴이 일시 중단된 후 재개되면 CoroutineDispatcher에 의해 재개된 코루틴을 다시 스레드에 보낸다.
- 이때 CoroutineDispatcher는 코루틴을 사용할 수 있는 스레드 중 하나에 보내기 때문에, 전,후의 스레드가 다를 수 있다.